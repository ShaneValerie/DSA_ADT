#include <stdio.h>
#include <stdlib.h>

#define MAX 20

typedef struct {
    int data;
    int LC;
    int RC;
} nodeType;

typedef struct {
    nodeType NODES[MAX];
    int avail;
} VH;

typedef enum { FALSE, TRUE } BOOL;

void initialize(int *root, VH *bst);
void insertElem(int *root, VH *bst, int elem);
int allocSpace(VH *bst);
BOOL isMember(int *root, VH bst, int elem);
void deleteElem(int *root, VH *bst, int elem);

int main() {
    int rootIndex;
    VH bst;
    BOOL choice;
    int value;

    printf("\n<< Cursor-Based Binary Search Tree >>\n");
    initialize(&rootIndex, &bst);

    printf("\nInsert elements into the tree\n");
    do {
        printf("\nInsert element? (1-Yes / 0-No): ");
        scanf("%d", &choice);

        if (choice == TRUE) {
            printf("Enter value: ");
            scanf("%d", &value);
            insertElem(&rootIndex, &bst, value);
        }
    } while (choice == TRUE);

    return 0;
}

void initialize(int *root, VH *bst) {
    int i;
    *root = -1;
    bst->avail = 0;

    for (i = 0; i < MAX; i++) {
        bst->NODES[i].LC = -1;
        bst->NODES[i].RC = (i < MAX - 1) ? i + 1 : -1;
    }
}

void insertElem(int *root, VH *bst, int elem) {
    if (isMember(root, *bst, elem) == TRUE) {
        printf("Duplicate value. Insertion cancelled.\n");
        return;
    }

    if (*root == -1) {
        int idx = allocSpace(bst);
        bst->NODES[idx].data = elem;
        bst->NODES[idx].LC = bst->NODES[idx].RC = -1;
        *root = idx;
        return;
    }

    if (elem < bst->NODES[*root].data) {
        insertElem(&bst->NODES[*root].LC, bst, elem);
    } else {
        insertElem(&bst->NODES[*root].RC, bst, elem);
    }
}

int allocSpace(VH *bst) {
    if (bst->avail == -1) {
        printf("Tree is full!\n");
        exit(1);
    }

    int idx = bst->avail;
    bst->avail = bst->NODES[idx].RC;
    return idx;
}

BOOL isMember(int *root, VH bst, int elem) {
    if (*root == -1)
        return FALSE;

    if (bst.NODES[*root].data == elem)
        return TRUE;

    if (elem < bst.NODES[*root].data)
        return isMember(&bst.NODES[*root].LC, bst, elem);
    else
        return isMember(&bst.NODES[*root].RC, bst, elem);
}

void deleteElem(int *root, VH *bst, int elem) {
    if (*root == -1)
        return;

    if (elem < bst->NODES[*root].data) {
        deleteElem(&bst->NODES[*root].LC, bst, elem);
    } 
    else if (elem > bst->NODES[*root].data) {
        deleteElem(&bst->NODES[*root].RC, bst, elem);
    } 
    else {
        int temp;

        if (bst->NODES[*root].LC == -1 && bst->NODES[*root].RC == -1) {
            temp = *root;
            *root = -1;
        }
        else if (bst->NODES[*root].LC == -1) {
            temp = *root;
            *root = bst->NODES[*root].RC;
        }
        else if (bst->NODES[*root].RC == -1) {
            temp = *root;
            *root = bst->NODES[*root].LC;
        }
        else {
            int succ = bst->NODES[*root].RC;
            while (bst->NODES[succ].LC != -1)
                succ = bst->NODES[succ].LC;

            bst->NODES[*root].data = bst->NODES[succ].data;
            deleteElem(&bst->NODES[*root].RC, bst, bst->NODES[succ].data);
            return;
        }

        bst->NODES[temp].RC = bst->avail;
        bst->avail = temp;
    }
}
